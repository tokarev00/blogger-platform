const crypto = require('crypto');
const {promisify} = require('util');

const randomBytesAsync = promisify(crypto.randomBytes);
const pbkdf2Async = promisify(crypto.pbkdf2);

function normalizeRounds(rounds) {
    const parsed = Number(rounds);
    if (!Number.isFinite(parsed) || parsed < 1) {
        return 1;
    }
    const floored = Math.floor(parsed);
    return floored > 15 ? 15 : floored;
}

async function hash(password, saltRounds = 10) {
    const rounds = normalizeRounds(saltRounds);
    const iterations = 1000 * Math.pow(2, rounds - 1);
    const saltBuffer = await randomBytesAsync(16);
    const salt = saltBuffer.toString('hex');
    const derivedKey = await pbkdf2Async(String(password), salt, iterations, 32, 'sha256');
    const digest = derivedKey.toString('hex');
    return `$stub$${iterations}$${salt}$${digest}`;
}

function hashSync(password, saltRounds = 10) {
    const rounds = normalizeRounds(saltRounds);
    const iterations = 1000 * Math.pow(2, rounds - 1);
    const salt = crypto.randomBytes(16).toString('hex');
    const derivedKey = crypto.pbkdf2Sync(String(password), salt, iterations, 32, 'sha256');
    const digest = derivedKey.toString('hex');
    return `$stub$${iterations}$${salt}$${digest}`;
}

async function compare(password, hashed) {
    try {
        const [empty, marker, iterationStr, salt, digest] = String(hashed).split('$');
        if (empty !== '' || marker !== 'stub') {
            return false;
        }
        const iterations = Number(iterationStr);
        if (!Number.isFinite(iterations) || iterations <= 0 || !salt || !digest) {
            return false;
        }
        const derivedKey = await pbkdf2Async(String(password), salt, iterations, 32, 'sha256');
        const expected = Buffer.from(digest, 'hex');
        return expected.length === derivedKey.length && crypto.timingSafeEqual(expected, derivedKey);
    } catch (error) {
        return false;
    }
}

function compareSync(password, hashed) {
    try {
        const [empty, marker, iterationStr, salt, digest] = String(hashed).split('$');
        if (empty !== '' || marker !== 'stub') {
            return false;
        }
        const iterations = Number(iterationStr);
        if (!Number.isFinite(iterations) || iterations <= 0 || !salt || !digest) {
            return false;
        }
        const derivedKey = crypto.pbkdf2Sync(String(password), salt, iterations, 32, 'sha256');
        const expected = Buffer.from(digest, 'hex');
        return expected.length === derivedKey.length && crypto.timingSafeEqual(expected, derivedKey);
    } catch (error) {
        return false;
    }
}

module.exports = {
    hash,
    hashSync,
    compare,
    compareSync,
};
